

#define PY_LOCAL_AGGRESSIVE


#include "nan_boxing.h"


#define likely(x) __builtin_expect(!!(x), 1)
#define unlikely(x) __builtin_expect(!!(x), 0)

// This uses the same nan boxing as WebKits JS engine with JSVALUE64:
// https://github.com/WebKit/WebKit/blob/main/Source/JavaScriptCore/runtime/JSCJSValue.h
// We can store in a 64bit value the following: (the highest 15 bit mark what type it is)
// - 48bit pointer  (highest bits: 0000)
// - 32bit int      (highest bits: FFFE)
// - double         (highest bits: everything else)
// Because for pointers the highest bits a zero a nan boxed pointer looks same as unboxed one.
// In order to make this work we need to add a fixed constant value when storing a double 1<<49.
// Type definition and the constants below are just copied from JSC
typedef union TaggedUnion {
    int64_t asInt64;
    PyObject* ptr;
    TaggedPointer tag;

    struct {
        int32_t asInt32;
        int32_t tag;
    } asBits;
} TaggedUnion;
const size_t DoubleEncodeOffsetBit = 49;
const int64_t DoubleEncodeOffset = 1ll << DoubleEncodeOffsetBit;
// If all bits in the mask are set, this indicates an integer number,
// if any but not all are set this value is a double precision number.
const int64_t NumberTag = 0xfffe000000000000ll;



static int64_t reinterpretDoubleToInt64(double value) {
    int64_t res;
    memcpy(&res, &value, sizeof(res));
    return res;
}
static double reinterpretInt64ToDouble(int64_t value) {
    double res;
    memcpy(&res, &value, sizeof(res));
    return res;
}
static int tagIsImpureNaN(double value){
    return (uint64_t)reinterpretDoubleToInt64(value) >= 0xfffe000000000000llu;
}

int tagIsNumber(TaggedPointer _tag) {
    TaggedUnion tag = (TaggedUnion)_tag;
    return (tag.asInt64 & NumberTag) != 0;
}
int tagIsLong(TaggedPointer _tag) {
    TaggedUnion tag = (TaggedUnion)_tag;
    return (tag.asInt64 & NumberTag) == NumberTag;
}
int tagIsDouble(TaggedPointer tag) {
    return tagIsNumber(tag) && !tagIsLong(tag);
}
int tagIsPtr(TaggedPointer tag) {
    return !tagIsNumber(tag);
}
static TaggedUnion fromTag(TaggedPointer ptr) {
    TaggedUnion tag;
    tag.ptr = ptr;
    return tag;
}


int tagAsInt32(TaggedPointer tag) {
    return fromTag(tag).asBits.asInt32;
}
double tagAsDouble(TaggedPointer tag) {
    return reinterpretInt64ToDouble(fromTag(tag).asInt64 - DoubleEncodeOffset);
}



TaggedPointer tagToLong(int64_t value) {
    TaggedUnion tag;
    if (INT_MIN <= value && value <= INT_MAX)
        tag.asInt64 = NumberTag | (uint32_t)value;
    else
        tag.ptr = PyLong_FromLong(value);
    return tag.tag;
}
TaggedPointer tagToDouble(double value) {
    TaggedUnion tag;
    if (!tagIsImpureNaN(value))
        tag.asInt64 = reinterpretDoubleToInt64(value) + DoubleEncodeOffset;
    else
        tag.ptr = PyFloat_FromDouble(value);
    return tag.tag;
}


PyObject* tagBox(TaggedPointer tag) {
    if (tagIsLong(tag)) {
        return PyLong_FromLong(tagAsInt32(tag));
    } else if (tagIsDouble(tag)) {
        return PyFloat_FromDouble(tagAsDouble(tag));
    }
    return fromTag(tag).ptr;
}
void tagBoxArray(PyObject** array, long len);

TaggedPointer tagUnbox(PyObject* value) {
    TaggedUnion tag;
    if (!tagIsPtr(value))
        return value; // this is already unboxed
    if (PyLong_CheckExact(value)) {
        long v = PyLong_AS_LONG(value);
        if (likely(INT_MIN <= v && v <= INT_MAX)) {
            tag.asInt64 = NumberTag | (uint32_t)v;
            return tag.tag;
        }
    } else if (PyFloat_CheckExact(value)) {
        double v = PyFloat_AS_DOUBLE(value);
        if (likely(!tagIsImpureNaN(v))) {
            tag.asInt64 = reinterpretDoubleToInt64(v) + DoubleEncodeOffset;
            return tag.tag;
        }
    }
    tag.ptr = value;
    return tag.tag;
}
void tagUnboxArray(PyObject** array, long len) {
    for (long i = 0; i < len; i++) {
        array[i] = tagUnbox(array[i]);
    }
}



// this should be generated by aot_gen.py
#if PYSTON_SPEEDUPS
#define SET_JIT_AOT_FUNC(dst_addr) do { \
    /* retrieve address of the instruction following the call instruction */\
    unsigned char* ret_addr = (unsigned char*)__builtin_extract_return_addr(__builtin_return_address(0));\
    if (ret_addr[-2] == 0xff && ret_addr[-1] == 0xd0) { /* abs call: call rax */\
        unsigned long* call_imm = (unsigned long*)&ret_addr[-2-8];\
        *call_imm = (unsigned long)dst_addr;\
    } else { /* relative call */ \
        /* 5 byte call instruction - get address of relative immediate operand of call */\
        unsigned int* call_imm = (unsigned int*)&ret_addr[-4];\
        /* set operand to newly calculated relative offset */\
        *call_imm = (unsigned int)(unsigned long)(dst_addr) - (unsigned int)(unsigned long)ret_addr;\
    } \
} while(0)


TaggedPointer tagAdd(PyObject* lhs, PyObject* rhs) {
    TaggedPointer unboxed_lhs = tagUnbox(lhs);
    if (tagIsPtr(unboxed_lhs))
        goto normal;
    TaggedPointer unboxed_rhs = tagUnbox(rhs);
    if (tagIsPtr(unboxed_rhs))
        goto normal;

    //fprintf(stderr, "tagAdd: %d + %d\n", tagIsLong(unboxed_lhs), tagIsLong(unboxed_rhs));
    //fprintf(stderr, "tagAdd: %d + %d\n", tagAsInt32(unboxed_lhs), tagAsInt32(unboxed_rhs));
    if (tagIsLong(unboxed_lhs) && tagIsLong(unboxed_rhs))
        return tagToLong((long)tagAsInt32(unboxed_lhs) + (long)tagAsInt32(unboxed_rhs));
    else if (tagIsLong(unboxed_lhs))
        return tagToDouble((double)tagAsInt32(unboxed_lhs) + tagAsDouble(unboxed_rhs));
    else
        return tagToDouble(tagAsDouble(unboxed_lhs) + (double)tagAsInt32(unboxed_rhs));

normal:
    return PyNumber_Add(lhs, rhs);
}

static TaggedPointer tagAddLong(PyObject* lhs, PyObject* rhs) {
    if (likely(tagIsLong(lhs) && tagIsLong(rhs)))
        return tagToLong((long)tagAsInt32(lhs) + (long)tagAsInt32(rhs));
    return tagAdd(lhs, rhs);
}
static TaggedPointer tagAddFloat(PyObject* lhs, PyObject* rhs) {
    if (likely(tagIsDouble(lhs) && tagIsDouble(rhs)))
        return tagToDouble(tagAsDouble(lhs) + (double)tagAsDouble(rhs));
    return tagAdd(lhs, rhs);
}
TaggedPointer tagAddProfile(PyObject* lhs, PyObject* rhs) {
    TaggedPointer (*func)(PyObject*, PyObject*);
    if (likely(tagIsLong(lhs) && tagIsLong(rhs)))
        func = tagAddLong;
    else if (likely(tagIsDouble(lhs) && tagIsDouble(rhs)))
        func = tagAddFloat;
    else
        func = tagAdd;
    SET_JIT_AOT_FUNC(func);
    return func(lhs, rhs);
}


static TaggedPointer tagMul(PyObject* lhs, PyObject* rhs) {
    TaggedPointer unboxed_lhs = tagUnbox(lhs);
    if (tagIsPtr(unboxed_lhs))
        goto normal;
    TaggedPointer unboxed_rhs = tagUnbox(rhs);
    if (tagIsPtr(unboxed_rhs))
        goto normal;

    if (tagIsLong(unboxed_lhs) && tagIsLong(unboxed_rhs))
        return tagToLong((long)tagAsInt32(unboxed_lhs) * (long)tagAsInt32(unboxed_rhs));
    else if (tagIsLong(unboxed_lhs))
        return tagToDouble((double)tagAsInt32(unboxed_lhs) * tagAsDouble(unboxed_rhs));
    else
        return tagToDouble(tagAsDouble(unboxed_lhs) * (double)tagAsInt32(unboxed_rhs));

normal:
    return PyNumber_Multiply(lhs, rhs);
}
static TaggedPointer tagMulLong(PyObject* lhs, PyObject* rhs) {
    if (likely(tagIsLong(lhs) && tagIsLong(rhs)))
        return tagToLong((long)tagAsInt32(lhs) * (long)tagAsInt32(rhs));
    return tagMul(lhs, rhs);
}
static TaggedPointer tagMulFloat(PyObject* lhs, PyObject* rhs) {
    if (likely(tagIsDouble(lhs) && tagIsDouble(rhs)))
        return tagToDouble(tagAsDouble(lhs) * (double)tagAsDouble(rhs));
    return tagMul(lhs, rhs);
}
TaggedPointer tagMulProfile(PyObject* lhs, PyObject* rhs) {
    TaggedPointer (*func)(PyObject*, PyObject*);
    if (likely(tagIsLong(lhs) && tagIsLong(rhs)))
        func = tagMulLong;
    else if (likely(tagIsDouble(lhs) && tagIsDouble(rhs)))
        func = tagMulFloat;
    else
        func = tagMul;
    SET_JIT_AOT_FUNC(func);
    return func(lhs, rhs);
}


static TaggedPointer tagSub(PyObject* lhs, PyObject* rhs) {
    TaggedPointer unboxed_lhs = tagUnbox(lhs);
    if (tagIsPtr(unboxed_lhs))
        goto normal;
    TaggedPointer unboxed_rhs = tagUnbox(rhs);
    if (tagIsPtr(unboxed_rhs))
        goto normal;

    if (tagIsLong(unboxed_lhs) && tagIsLong(unboxed_rhs))
        return tagToLong((long)tagAsInt32(unboxed_lhs) - (long)tagAsInt32(unboxed_rhs));
    else if (tagIsLong(unboxed_lhs))
        return tagToDouble((double)tagAsInt32(unboxed_lhs) - tagAsDouble(unboxed_rhs));
    else
        return tagToDouble(tagAsDouble(unboxed_lhs) - (double)tagAsInt32(unboxed_rhs));

normal:
    return PyNumber_Subtract(lhs, rhs);
}
static TaggedPointer tagSubLong(PyObject* lhs, PyObject* rhs) {
    if (likely(tagIsLong(lhs) && tagIsLong(rhs)))
        return tagToLong((long)tagAsInt32(lhs) - (long)tagAsInt32(rhs));
    return tagSub(lhs, rhs);
}
static TaggedPointer tagSubFloat(PyObject* lhs, PyObject* rhs) {
    if (likely(tagIsDouble(lhs) && tagIsDouble(rhs)))
        return tagToDouble(tagAsDouble(lhs) - (double)tagAsDouble(rhs));
    return tagSub(lhs, rhs);
}
TaggedPointer tagSubProfile(PyObject* lhs, PyObject* rhs) {
    TaggedPointer (*func)(PyObject*, PyObject*);
    if (likely(tagIsLong(lhs) && tagIsLong(rhs)))
        func = tagSubLong;
    else if (likely(tagIsDouble(lhs) && tagIsDouble(rhs)))
        func = tagSubFloat;
    else
        func = tagSub;
    SET_JIT_AOT_FUNC(func);
    return func(lhs, rhs);
}


double float_pow_unboxed(double iv, double iw, int* err);
TaggedPointer tagPow(PyObject* lhs, PyObject* rhs) {
    if (likely(tagIsDouble(lhs) && tagIsDouble(rhs))) {
        int err = 0;
        double res = float_pow_unboxed(tagAsDouble(lhs), tagAsDouble(rhs), &err);
        if (likely(res))
            return tagToDouble(res);
        return 0;
    }

    int need_decref_lhs = !tagIsPtr(lhs);
    if (need_decref_lhs)
        lhs = tagBox(lhs);
    int need_decref_rhs = !tagIsPtr(rhs);
    if (need_decref_rhs)
        rhs = tagBox(rhs);
    TaggedPointer ret = tagUnbox(PyNumber_Power(lhs, rhs, Py_None));
    if (need_decref_lhs)
        Py_DECREF(lhs);
    if (need_decref_rhs)
        Py_DECREF(rhs);
    return ret;
}

#endif
